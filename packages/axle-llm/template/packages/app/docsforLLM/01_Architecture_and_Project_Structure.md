# AxleLLM: Architecture and Project Structure

**Objective:** This document provides a high-level overview of the AxleLLM architecture, the standard project structure generated by the CLI, and the engine's data flow for both initial render and subsequent updates.

---

## 1. Core Philosophy

Understanding the philosophy is critical to using the framework correctly.

-   **You are a System Architect, not a Coder:** Your primary function is to define the system's components and the relationships between them. You achieve this by editing declarative JavaScript objects, not by writing procedural logic.

-   **Declarative by Default, Imperative by Exception:** The framework is designed around a declarative core. You define the desired state, and the engine determines how to achieve it. Imperative logic is treated as an exception, isolated in specific, designated files (`app/actions/`, `app/bridge/`) and is only used when absolutely necessary.

-   **The Manifest is the Application:** The `manifest/` directory is not just a configuration folder; it *is* the application's brain. The engine reads this directory to build a complete model of the application's capabilities, data requirements, and logic flows.

-   **Safety and Predictability through Whitelisting:** The application operates in a secure sandbox. It has no inherent ability to interact with the host operating system. Every single native function—from showing a simple dialog box to writing a file—must be explicitly permitted in `manifest/bridge.js`. This makes the application's potential side effects fully auditable and predictable.

-   **Data-Driven UI:** The User Interface is a direct, stateless reflection of the application's data. To change what the user sees, you change the data stored in a `connector`. The engine automatically detects this change and re-renders the necessary parts of the UI. There is no manual DOM manipulation.

---

## 2. Standard Project Structure

The `npx axle-llm new <app-name>` command generates a professional **monorepo** structure. This setup provides maximum stability and transparency.

**Your work is focused almost exclusively inside the `packages/app/` directory.**

```
<app-name>/
│
├── packages/
│   │
│   ├── axle-llm/   # The complete source code of the AxleLLM engine.
│   │
│   └── app/        # ★★★ YOUR APPLICATION WORKSPACE ★★★
│       │
│       ├── app/
│       │   ├── actions/      # Houses imperative JavaScript modules for complex logic.
│       │   ├── bridge/       # Houses custom Node.js modules for native OS interaction.
│       │   └── components/   # Houses all UI definition files (.jsx, .css).
│       │
│       ├── manifest/ # The architectural blueprint of your application.
│       │   │
│       │   ├── bridge.js     # The Whitelist for native functions.
│       │   ├── components.js # The UI Registry and data schemas.
│       │   ├── connectors.js # The Data Layer definition.
│       │   └── routes/       # The Logic Layer (views and actions).
│       │
│       ├── manifest.js       # The root configuration file for your app.
│       │
│       ├── .axle-build/      # (Generated) Server-side bundled React components.
│       ├── .axle-build-client/ # (Generated) Client-side bundled React components.
│       ├── public/           # (Generated) The final client-side bundle (bundle.js).
│       │
│       ├── axle-db-data/     # (Generated) Storage for persistent data.
│       │
│       └── package.json      # Your app's specific dependencies.
│
└── package.json              # The root package.json for the monorepo.
```

---

## 3. High-Level Data Flow and Rendering Cycle

The engine follows a strict, two-phase process.

### Phase 1: Initial Load (Server-Side Rendering & Hydration)

This phase occurs once when the application starts or a view is navigated to. Its goal is to display a fully rendered UI to the user as quickly as possible.

1.  **Request:** The Electron main process requests a URL (e.g., `GET /`) from the internal Node.js server.
2.  **Route Matching:** The `RequestHandler` finds the corresponding `view` route in the manifest.
3.  **Data Fetching:** The `ConnectorManager` loads all data from the connectors listed in the route's `reads` array.
4.  **Server-Side Render (SSR):** The `Renderer` loads the server-side bundled React components (`.axle-build/`). It constructs the entire component tree in memory and renders it to a static **HTML string**.
5.  **HTML Response:** The server sends a full HTML document to the Electron window. This document contains:
    *   The pre-rendered HTML.
    *   All required CSS styles.
    *   A `<script>` tag containing all the initial data (`window.__INITIAL_DATA__`).
    *   A `<script>` tag to load the client-side bundle (`/public/bundle.js`).
6.  **Instant Paint:** The user immediately sees the complete UI. It is not yet interactive.
7.  **Hydration:** The client-side `bundle.js` executes. The `engine-client.js` finds the existing server-rendered HTML and uses `ReactDOM.hydrateRoot` to attach React's event listeners, turning the static page into a fully interactive Single-Page Application (SPA).

### Phase 2: Interactive Update (Action Loop)

This cycle is triggered every time a user interacts with an element containing an `atom-action` attribute.

1.  **Event Trigger:** The user clicks a button, submits a form, etc.
2.  **Client-Side Intercept:** `engine-client.js` prevents the default browser action and captures the event.
3.  **AJAX Request:** The client sends a `fetch` request (e.g., `POST /action/addItem`) to the internal server, including any form data in the body.
4.  **Route Matching:** The `RequestHandler` finds the corresponding `action` route in the manifest.
5.  **Context Assembly:** The `ConnectorManager` loads data from the connectors listed in the `reads` array.
6.  **Step Execution:** The `ActionEngine` executes the `steps` array sequentially, modifying data within its execution context.
7.  **Data Persistence:** The engine saves the modified data back to the connectors listed in the `writes` array.
8.  **Payload Generation:** The `RequestHandler` identifies the component to be updated (from the `update` property). It then determines the **full data requirements for that entire view** by finding the original `view` route and re-fetching all of its `reads` connectors.
9.  **JSON Response:** The server sends a JSON payload to the client containing:
    *   The name of the component to update (e.g., `cashierPage`).
    *   A `props` object with the complete, fresh data for the entire view.
10. **Client-Side Re-render:** `engine-client.js` receives the payload. It finds the target DOM element (`atom-target`) and uses `root.render()` to have React efficiently update the DOM with the new content. The application state is now consistent between the server and the client.