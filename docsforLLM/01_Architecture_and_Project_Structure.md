# AxleLLM: Architecture and Project Structure

**Objective:** This document provides a high-level overview of the AxleLLM architecture, the standard project structure generated by the CLI, and the engine's data flow.

---

## 1. Core Philosophy

Understanding the philosophy is critical to using the framework correctly.

-   **You are a System Architect, not a Coder:** Your primary function is to define the system's components and the relationships between them. You achieve this by editing declarative JavaScript objects, not by writing procedural logic.

-   **Declarative by Default, Imperative by Exception:** The framework is designed around a declarative core. You define the desired state, and the engine determines how to achieve it. Imperative logic is treated as an exception, isolated in specific, designated files (`app/actions/`, `app/bridge/`) and is only used when absolutely necessary.

-   **The Manifest is the Application:** The `manifest/` directory is not just a configuration folder; it *is* the application's brain. The engine reads this directory to build a complete model of the application's capabilities, data requirements, and logic flows.

-   **Safety and Predictability through Whitelisting:** The application operates in a secure sandbox. It has no inherent ability to interact with the host operating system. Every single native function—from showing a simple dialog box to writing a file—must be explicitly permitted in `manifest/bridge.js`. This makes the application's potential side effects fully auditable and predictable.

-   **Data-Driven UI:** The User Interface is a direct, stateless reflection of the application's data. To change what the user sees, you change the data stored in a `connector`. The engine automatically detects this change and re-renders the necessary parts of the UI. There is no manual DOM manipulation.

---

## 2. Standard Project Structure

The `npx axle-llm new <app-name>` command generates a standardized, self-contained project. Understanding the role of each file and directory is essential.

```
my-app/
│
├── app/  # Contains the "physical" assets of your application.
│   │
│   ├── actions/      # Houses imperative JavaScript modules for complex logic.
│   │   │             # Used by `run` and `run:set` steps in routes.
│   │   │             # Example: `calculateTotals.js`
│   │   │
│   ├── bridge/       # Houses custom Node.js modules for native OS interaction.
│   │   │             # These are the implementation details for your server-side bridge.
│   │   │             # Example: `fileSaver.js`
│   │   │
│   └── components/   # Houses all UI definition files.
│       │             # Contains .html templates and their corresponding .css style files.
│       │             # Example: `user-profile.html`, `user-profile.css`
│
├── manifest/ # The architectural blueprint of your application.
│   │
│   ├── bridge.js     # **The Whitelist.** Defines every native function the app can call.
│   ├── components.js # **The UI Registry.** Maps component names to their .html/.css files and defines their data contracts (schemas).
│   ├── connectors.js # **The Data Layer.** Defines all data sources, their type (in-memory or persistent), and their initial state.
│   └── routes.js     # **The Logic Layer.** Defines all `view` endpoints for rendering UI and all `action` endpoints for executing business logic via `steps`.
│
├── manifest.js       # The root configuration file for high-level settings like window properties, theming, and global variables.
│
├── axle-db-data/     # (Generated at runtime) Storage location for `wise-json` connectors.
│
└── package.json      # Standard Node.js file for project dependencies and scripts.
```

---

## 3. High-Level Data Flow

The engine follows a strict, unidirectional data flow for every user interaction.

1.  **Event Trigger:** A user interacts with a UI element that has an `atom-action` attribute (e.g., `<button atom-action="POST /action/save-user">`).

2.  **Request to Server:** The client-side engine captures the event, packages the relevant data (e.g., from a form), and sends an HTTP request to the internal server running within Electron.

3.  **Route Matching:** The server finds the corresponding `action` route in `manifest/routes.js` (e.g., `"POST /action/save-user": { ... }`).

4.  **Context Assembly:**
    *   The engine identifies the connectors listed in the route's `reads` array (e.g., `["user"]`).
    *   It retrieves the current data from those connectors.
    *   It assembles an `execution context` object containing this data, available under the `data` key (e.g., `{ data: { user: { ... } } }`). The context also includes form data (`body`) and session data (`user`).

5.  **Sequential Step Execution:** The engine executes the `steps` array defined in the route, one by one. Each step operates on the `execution context`.
    *   `{ "set": "data.user.name", "to": "body.newName" }` modifies the user's name *within the temporary context*.

6.  **Data Persistence:** After the final step has been executed without error, the engine checks the route's `writes` array (e.g., `["user"]`). It takes the final state of `data.user` from the context and saves it back to the `user` connector, persisting the change.

7.  **UI Invalidation and Re-rendering:**
    *   The engine checks the route's `update` property (e.g., `"userProfile"`).
    *   It re-renders the `userProfile` component, passing it the new, updated data from the context.
    *   The resulting HTML and CSS are sent back to the client.

8.  **DOM Patching:** The client-side engine receives the new HTML and intelligently replaces the old component in the DOM with the new version.```