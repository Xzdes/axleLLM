# AxleLLM: Architecture and Project Structure

**Objective:** This document provides a high-level overview of the AxleLLM architecture, the standard project structure generated by the CLI, and the engine's data flow.

---

## 1. Core Philosophy

Understanding the philosophy is critical to using the framework correctly.

-   **You are a System Architect, not a Coder:** Your primary function is to define the system's components and the relationships between them. You achieve this by editing declarative JavaScript objects, not by writing procedural logic.

-   **Declarative by Default, Imperative by Exception:** The framework is designed around a declarative core. You define the desired state, and the engine determines how to achieve it. Imperative logic is treated as an exception, isolated in specific, designated files (`app/actions/`, `app/bridge/`) and is only used when absolutely necessary.

-   **The Manifest is the Application:** The `manifest/` directory is not just a configuration folder; it *is* the application's brain. The engine reads this directory to build a complete model of the application's capabilities, data requirements, and logic flows.

-   **Safety and Predictability through Whitelisting:** The application operates in a secure sandbox. It has no inherent ability to interact with the host operating system. Every single native function—from showing a simple dialog box to writing a file—must be explicitly permitted in `manifest/bridge.js`. This makes the application's potential side effects fully auditable and predictable.

-   **Data-Driven UI:** The User Interface is a direct, stateless reflection of the application's data. To change what the user sees, you change the data stored in a `connector`. The engine automatically detects this change and re-renders the necessary parts of the UI. There is no manual DOM manipulation.

---

## 2. Standard Project Structure

The `npx axle-llm new <app-name>` command generates a professional **monorepo** structure. This setup provides maximum stability and transparency, allowing you to see both your application code and the engine's source code side-by-side.

**Your work is focused almost exclusively inside the `packages/app/` directory.**

```
<app-name>/
│
├── packages/
│   │
│   ├── axle-llm/   # The complete source code of the AxleLLM engine.
│   │   │           # You generally don't need to touch this, but it's here for transparency and advanced debugging.
│   │   └── ...
│   │
│   └── app/        # ★★★ YOUR APPLICATION WORKSPACE ★★★
│       │
│       ├── app/  # Contains the "physical" assets of your application.
│       │   │
│       │   ├── actions/      # Houses imperative JavaScript modules for complex logic.
│       │   ├── bridge/       # Houses custom Node.js modules for native OS interaction.
│       │   └── components/   # Houses all UI definition files (.html, .css).
│       │
│       ├── manifest/ # The architectural blueprint of your application.
│       │   │
│       │   ├── bridge.js     # The Whitelist for native functions.
│       │   ├── components.js # The UI Registry and data schemas.
│       │   ├── connectors.js # The Data Layer definition.
│       │   └── routes.js     # The Logic Layer (views and actions).
│       │
│       ├── manifest.js       # The root configuration file for your app.
│       │
│       ├── axle-db-data/     # (Generated at runtime) Storage for persistent data.
│       │
│       └── package.json      # Your app's specific dependencies (e.g., `wise-json-db`).
│
├── node_modules/             # Shared dependencies for the entire monorepo.
│
├── .gitignore
│
└── package.json              # The root package.json for the monorepo (manages workspaces, Electron).
```

---

## 3. High-Level Data Flow

The engine follows a strict, unidirectional data flow for every user interaction. This logic remains unchanged.

1.  **Event Trigger:** A user interacts with a UI element that has an `atom-action` attribute.

2.  **Request to Server:** The client-side engine captures the event, packages the data, and sends an HTTP request to the internal server.

3.  **Route Matching:** The server finds the corresponding `action` route in `packages/app/manifest/routes.js`.

4.  **Context Assembly:** The engine retrieves data from the connectors listed in the route's `reads` array.

5.  **Sequential Step Execution:** The engine executes the `steps` array defined in the route, one by one.

6.  **Data Persistence:** The engine saves the modified data back to the connectors listed in the route's `writes` array.

7.  **UI Invalidation and Re-rendering:** The engine re-renders the component specified in the route's `update` property.

8.  **DOM Patching:** The client-side engine intelligently replaces the old component in the DOM with the new version.
